
   1 COMPILER Parva $CN
   2 /* Parva level 1 grammar  - Coco/R for C# (EBNF)
   3    P.D. Terry, Rhodes University, 2016
   4    Extended Grammar similar to that done in Prac 3  */
   5 
   6     static Table table = new Table();
   7    
   8 CHARACTERS
   9   lf         = CHR(10) .
  10   backslash  = CHR(92) .
  11   control    = CHR(0) .. CHR(31) .
  12   letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  13   digit      = "0123456789" .
  14   stringCh   = ANY - '"' - control - backslash .
  15   charCh     = ANY - "'" - control - backslash .
  16   printable  = ANY - control .
  17 
  18 TOKENS
  19 
  20 /* Insisting that identifiers cannot end with an underscore is quite easy */
  21 
  22   identifier = letter { letter | digit | "_" { "_" } ( letter | digit ) } .
  23 
  24 /* but a simpler version is what many people think of
  25 
  26   identifier = letter { letter | digit | "_" ( letter | digit ) } .
  27 
  28    Technically this is not quite what was asked.  The restriction is really that an
  29    identifier cannot end with an underscore.  Identifiers like Pat_____Terry are allowed: */
  30 
  31   number     = digit { digit } .
  32   stringLit  = '"' { stringCh | backslash printable } '"' .
  33   charLit    = "'" ( charCh   | backslash printable ) "'" .
  34 
  35 COMMENTS FROM "//" TO lf
  36 COMMENTS FROM "/*" TO "*/"
  37 IGNORE CHR(9) .. CHR(13)
  38 
  39 PRODUCTIONS
  40   Parva             = "void"
  41                     Ident
  42                     (. Table.declare(token.val, funcKind, noType, token.line); .)
  43                     "(" ")"
  44                     Block
  45                     (. Table.PrintTable(); .) .
  46   Block             = "{"
  47                     { Statement }
  48                     "}" .
  49 
  50 /* The options in Statement are easily extended to handle the new forms */
  51 
  52   Statement         =    Block
  53                        | ConstDeclarations | VarDeclarations
  54                        | Assignments
  55                        | IfStatement       | WhileStatement
  56                        | ReturnStatement   | HaltStatement
  57                        | ReadStatement     | WriteStatement
  58                        | ForStatement      | BreakStatement
  59                        | ContinueStatement | DoWhileStatement
  60                        | ";" .
  61 
  62 /* Declarations remain the same as before */
  63 
  64   ConstDeclarations = "const" OneConst { "," OneConst } ";" .
  65   OneConst          = Ident
  66                     (. string name = token.val; .)
  67                     (.int kind = constKind, value = 0, type = noType, lineRef = token.line; .)
  68                     "="
  69                     Constant < out value, out type >
  70                     (. Table.declare(name, kind, type, value); .)
  71                     .
  72   Constant < out int value, out int type >
  73                     =
  74                     number (. value = Convert.ToInt32(token.val); type = intType; .)
  75                     | charLit (. value = Convert.ToInt32(token.val[1]); type = charType; .)
  76                     | "true" (. value = 1; type = boolType; .)
  77                     | "false" (. value = 0; type = boolType; .)
  78                     | "null" (. value = 0; type = noType; .)
  79                     .
  80   VarDeclarations   = Type OneVar { "," OneVar } ";" .
  81 
  82 /* We can introduce the extra form of asssignment operators as tokens as follows.  Note
  83    theta we do not want to use, say "+" "=" because they cannot contain spaces. */
  84 
  85   CompoundAssignOp  = "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" .
  86 
  87 /* Don't be tempted to use the CompoundAssignOp in the declaration of OneVar or OneConst.
  88    It cannot have a proper semantic meaning if you do.  All you can use is "=" */
  89 
  90   OneVar            = Ident
  91                     (. Table.AddRef(token.val, true, token.line); .)
  92                     [ "=" Expression ] .
  93 
  94 /* One way of introducing the extended form of assignment statements might be to define
  95 
  96   Assignments = Designator { "," Designator } ( "=" | CompoundAssignOp )
  97                 Expression { "," Expression } .
  98 
  99 */
 100 
 101 /* However, we might wish to limit the form with multiple Designators and Expressions to
 102    use only the simple = operator, for ease of code generation as we may see later.
 103 
 104    If this is the case, to keep thing LL(1) compliant, the extra forms of assignment
 105    statement familiar from Python, and the compound assignments familiar from C and C# are
 106    best handled as below.  THis affords a nice example of factoring a grammar to avoid
 107    LL(1) conflicts by delaying the awkward component for a while */
 108 
 109   Assignments       = Designator
 110                       (   CompoundAssignOp Expression
 111                         | { "," Designator } "=" Expression { "," Expression }
 112                         | "++"
 113                         | "--"
 114                       ) ";" .
 115 
 116   Designator        = Ident                    
 117                     [ "[" Expression "]" ] .
 118 
 119 /* The if-then-elsif-else construction is most easily described as follows. Although
 120   this is not LL(1), this works admirably - it is simply the well-known dangling
 121   else ambiguity, which the parser resolves by associating elsif and else clauses
 122   with the most recent if */
 123 
 124   IfStatement       = "if" "(" Condition ")" Statement
 125                       { "elsif" "(" Condition ")" Statement }
 126                       [ "else" Statement ] .
 127 
 128   WhileStatement    = "while" "(" Condition ")" Statement .
 129 
 130 /* Remember that the DoWhile statement must end with a semicolon - easy to forget this!
 131    Why don't we need a semicolon as a terminator for a WhileStatement or IfStatement? */
 132 
 133   DoWhileStatement  = "do"  Statement  "while" "(" Condition ")" ";" .
 134 
 135 /* Break and Continue statements are very simple.  They are really "context dependent" but we
 136    cannot impose such restrictions in a context-free grammar.  And they also need their own
 137    terminating semicolons, which tend to be forgotten. */
 138 
 139   BreakStatement    = "break"    ";" .
 140   ContinueStatement = "continue" ";" .
 141 
 142   ReturnStatement   = "return"   ";" .
 143   HaltStatement     = "halt"     ";" .
 144 
 145 /* a C# inspired ForStatement might look like this */
 146 
 147   ForStatement      = "for" "(" (. bool temp = false; .) 
 148                         [ [ BasicType (. temp = true; .) ]
 149                         Ident
 150                         (. Table.AddRef(token.val, temp, token.line); .)
 151                         "=" Expression ]
 152                         ";"
 153                         [ Condition ] ";"
 154                         [ Step ]
 155                       ")" Statement .
 156 
 157   Step              =  Ident
 158                     (. Table.AddRef(token.val, false, token.line); .)
 159                     ( "++" | "--" | ( "=" | CompoundAssignOp ) Expression ) .
 160 
 161   ReadStatement     = "read" "(" ReadElement { "," ReadElement } ")" ";" .
 162   ReadElement       = stringLit 
 163                       | Designator 
 164                       (. Table.AddRef(token.val, true, token.line); .) .
 165   WriteStatement    = "write" "(" WriteElement { "," WriteElement } ")" ";" .
 166   WriteElement      = stringLit | Expression .
 167   Condition         = Expression .
 168   Expression        = AddExp [ RelOp AddExp ] .
 169   AddExp            = [ "+" | "-" ] Term { AddOp Term } .
 170   Term              = Factor { MulOp Factor } .
 171   Factor            = Designator  (. Table.AddRef(token.val, false, token.line); .)
 172                       | Constant
****                         ^ attribute mismatch between declaration and use of this symbol
 173                       | "new" BasicType "[" Expression "]"
 174                       | "!" Factor | "(" Expression ")" .
 175   Type              = BasicType [ "[]" ] .
 176   BasicType         = "int" | "bool" .
 177   AddOp             = "+" | "-" | "||" .
 178 
 179 /* The % operator is easily added to the set of MulOps */
 180 
 181   MulOp             = "*" | "/" | "&&" | "%" .
 182 
 183   RelOp             = "==" | "!=" | "<" | "<=" | ">" | ">=" .
 184 
 185   Ident             = identifier .
 186 
 187 END Parva.

1 errors detected
