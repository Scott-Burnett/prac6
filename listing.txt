  LL1 warning in IfStatement: "elsif" is the start & successor of a deletable structure
  LL1 warning in IfStatement: "else" is the start & successor of a deletable structure

   1 /*using Table.cs;*/
   2 COMPILER Parva $CN
   3 /* Parva level 1 grammar  - Coco/R for C# (EBNF)
   4    P.D. Terry, Rhodes University, 2016
   5    Extended Grammar similar to that done in Prac 3  */
   6 
   7     static Table table = new Table();
   8    
   9 CHARACTERS
  10   lf         = CHR(10) .
  11   backslash  = CHR(92) .
  12   control    = CHR(0) .. CHR(31) .
  13   letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  14   digit      = "0123456789" .
  15   stringCh   = ANY - '"' - control - backslash .
  16   charCh     = ANY - "'" - control - backslash .
  17   printable  = ANY - control .
  18 
  19 TOKENS
  20 
  21 /* Insisting that identifiers cannot end with an underscore is quite easy */
  22 
  23   identifier = letter { letter | digit | "_" { "_" } ( letter | digit ) } .
  24 
  25 /* but a simpler version is what many people think of
  26 
  27   identifier = letter { letter | digit | "_" ( letter | digit ) } .
  28 
  29    Technically this is not quite what was asked.  The restriction is really that an
  30    identifier cannot end with an underscore.  Identifiers like Pat_____Terry are allowed: */
  31 
  32   number     = digit { digit } .
  33   stringLit  = '"' { stringCh | backslash printable } '"' .
  34   charLit    = "'" ( charCh   | backslash printable ) "'" .
  35 
  36 COMMENTS FROM "//" TO lf
  37 COMMENTS FROM "/*" TO "*/"
  38 IGNORE CHR(9) .. CHR(13)
  39 
  40 PRODUCTIONS
  41   Parva             = "void"
  42                     Ident
  43                     (. table.AddRef(token.val, true, token.line); .)
  44                     "(" ")"
  45                     Block .
  46   Block             = "{"
  47                     { Statement }
  48                     "}" .
  49 
  50 /* The options in Statement are easily extended to handle the new forms */
  51 
  52   Statement         =    Block
  53                        | ConstDeclarations | VarDeclarations
  54                        | Assignments
  55                        | IfStatement       | WhileStatement
  56                        | ReturnStatement   | HaltStatement
  57                        | ReadStatement     | WriteStatement
  58                        | ForStatement      | BreakStatement
  59                        | ContinueStatement | DoWhileStatement
  60                        | ";" .
  61 
  62 /* Declarations remain the same as before */
  63 
  64   ConstDeclarations = "const" OneConst { "," OneConst } ";" .
  65   OneConst          = Ident
  66                     (. table.AddRef(token.val, true, token.line); .)
  67                     "="
  68                     Constant .
  69   Constant          =   number | charLit
  70                       | "true" | "false" | "null" .
  71   VarDeclarations   = Type OneVar { "," OneVar } ";" .
  72 
  73 /* We can introduce the extra form of asssignment operators as tokens as follows.  Note
  74    theta we do not want to use, say "+" "=" because they cannot contain spaces. */
  75 
  76   CompoundAssignOp  = "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" .
  77 
  78 /* Don't be tempted to use the CompoundAssignOp in the declaration of OneVar or OneConst.
  79    It cannot have a proper semantic meaning if you do.  All you can use is "=" */
  80 
  81   OneVar            = Ident
  82                     (. table.AddRef(token.val, true, token.line); .)
  83                     [ "=" Expression ] .
  84 
  85 /* One way of introducing the extended form of assignment statements might be to define
  86 
  87   Assignments = Designator { "," Designator } ( "=" | CompoundAssignOp )
  88                 Expression { "," Expression } .
  89 
  90 */
  91 
  92 /* However, we might wish to limit the form with multiple Designators and Expressions to
  93    use only the simple = operator, for ease of code generation as we may see later.
  94 
  95    If this is the case, to keep thing LL(1) compliant, the extra forms of assignment
  96    statement familiar from Python, and the compound assignments familiar from C and C# are
  97    best handled as below.  THis affords a nice example of factoring a grammar to avoid
  98    LL(1) conflicts by delaying the awkward component for a while */
  99 
 100   Assignments       = Designator
 101                       (   CompoundAssignOp Expression
 102                         | { "," Designator } "=" Expression { "," Expression }
 103                         | "++"
 104                         | "--"
 105                       ) ";" .
 106 
 107   Designator        = Ident
 108                     (. table.AddRef(token.val, true, token.line); .)
 109                     [ "[" Expression "]" ] .
 110 
 111 /* The if-then-elsif-else construction is most easily described as follows. Although
 112   this is not LL(1), this works admirably - it is simply the well-known dangling
 113   else ambiguity, which the parser resolves by associating elsif and else clauses
 114   with the most recent if */
 115 
 116   IfStatement       = "if" "(" Condition ")" Statement
 117                       { "elsif" "(" Condition ")" Statement }
 118                       [ "else" Statement ] .
 119 
 120   WhileStatement    = "while" "(" Condition ")" Statement .
 121 
 122 /* Remember that the DoWhile statement must end with a semicolon - easy to forget this!
 123    Why don't we need a semicolon as a terminator for a WhileStatement or IfStatement? */
 124 
 125   DoWhileStatement  = "do"  Statement  "while" "(" Condition ")" ";" .
 126 
 127 /* Break and Continue statements are very simple.  They are really "context dependent" but we
 128    cannot impose such restrictions in a context-free grammar.  And they also need their own
 129    terminating semicolons, which tend to be forgotten. */
 130 
 131   BreakStatement    = "break"    ";" .
 132   ContinueStatement = "continue" ";" .
 133 
 134   ReturnStatement   = "return"   ";" .
 135   HaltStatement     = "halt"     ";" .
 136 
 137 /* a C# inspired ForStatement might look like this */
 138 
 139   ForStatement      = "for" "("
 140                         [ [ BasicType ]
 141                         Ident
 142                         (. table.AddRef(token.val, true, token.line); .)
 143                         "=" Expression ]
 144                         ";"
 145                         [ Condition ] ";"
 146                         [ Step ]
 147                       ")" Statement .
 148 
 149   Step              =  Ident
 150                     (. table.AddRef(token.val, false, token.line); .)
 151                     ( "++" | "--" | ( "=" | CompoundAssignOp ) Expression ) .
 152 
 153   ReadStatement     = "read" "(" ReadElement { "," ReadElement } ")" ";" .
 154   ReadElement       = stringLit | Designator .
 155   WriteStatement    = "write" "(" WriteElement { "," WriteElement } ")" ";" .
 156   WriteElement      = stringLit | Expression .
 157   Condition         = Expression .
 158   Expression        = AddExp [ RelOp AddExp ] .
 159   AddExp            = [ "+" | "-" ] Term { AddOp Term } .
 160   Term              = Factor { MulOp Factor } .
 161   Factor            =   Designator | Constant
 162                       | "new" BasicType "[" Expression "]"
 163                       | "!" Factor | "(" Expression ")" .
 164   Type              = BasicType [ "[]" ] .
 165   BasicType         = "int" | "bool" .
 166   AddOp             = "+" | "-" | "||" .
 167 
 168 /* The % operator is easily added to the set of MulOps */
 169 
 170   MulOp             = "*" | "/" | "&&" | "%" .
 171 
 172   RelOp             = "==" | "!=" | "<" | "<=" | ">" | ">=" .
 173 
 174   Ident             = identifier .
 175 
 176 END Parva.
 177 

0 errors detected
2 warnings detected
